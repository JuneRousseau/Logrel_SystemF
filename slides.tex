\documentclass[xcolor={usenames,dvipsnames}]{beamer}
\title{Formalizing logical relation for System F type safety in Coq}
\author{Bastien ROUSSEAU}
\date{2023}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{mathpartir}
\usepackage{pftools}

\usepackage{generalMacros}
\usepackage{syntaxColor}
\input{macros}

% \usepackage{capt-of}
% \usepackage{circledsteps}
% \input{macros}

% \theoremstyle{plain}
% \newtheorem*{theorem*}{Theorem}
% \newtheorem*{lemma*}{Lemma}
% \newtheorem*{definition*}{Definition}

% \usepackage{biblatex}
% \addbibresource{/home/au711415/Work/SystemF_Safe/biblio.bib}
% \addbibresource{~/Work/master.bib}


% \usepackage{iris}
% \usepackage{macrosIris}
% \usepackage{macrosCerise}


% \usepackage{listings}
% \usepackage{setspace}
% \usepackage{subcaption}
% \usepackage{wrapfig}
% \usepackage{rotating}
% \usepackage[normalem]{ulem}

% \captionsetup[subfigure]{labelformat=empty}
% % Adjust the size of tabulars
% \usepackage{adjustbox}
% % Color tabular cells
% \usepackage{xcolor,colortbl}
% % Color verbatim
% \usepackage{fancyvrb}
% % Pretty tabulars
% \usepackage{booktabs}
% \usepackage{subcaption}

% % Better tabular with fixed-size columns
% \usepackage{tabularx}
% \makeatletter
% \newcommand\cellwidth{\TX@col@width}
% \newcolumntype{C}{>{\centering\arraybackslash}X}
% \newcolumntype{Z}{>{\raggedleft\arraybackslash}X}
% \makeatother

% MOTIVATION FOR STRONG NORMALIZATION

% Theme
\usecolortheme{beaver}
\beamertemplatenavigationsymbolsempty
\setbeamercolor{palette primary}{bg=white,fg=black}
\setbeamercolor{palette secondary}{bg=white,fg=black}
\setbeamercolor{palette tertiary}{bg=white,fg=black}
\setbeamercolor{palette quaternary}{bg=white,fg=black}
\setbeamercolor{structure}{bg=white,fg=black}
\setbeamercolor{titlelike}{bg=white,fg=black}
\setbeamercolor{title}{bg=white,fg=black}
\setbeamercolor{title in head/foot}{bg=white,fg=black}
\setbeamercolor{section in head/foot}{bg=white,fg=black}
\setbeamercolor{subsection in head/foot}{bg=white,fg=black}
\setbeamercolor{frametitle}{bg=white,fg=black}
\setbeamertemplate{footline}[frame number]
\newcommand\xxsectiontitle[1]{\begin{center}\Huge{#1}\end{center}}
\renewcommand\section[1]{\begin{frame}[noframenumbering]{}\xxsectiontitle{#1}\end{frame}}
\setbeamertemplate{blocks}[rounded][shadow=true]
\setbeamercolor{block title}{bg=black!5, fg=black}


\begin{document}

\frame{\titlepage}

\begin{frame}
  \frametitle{Introduction}

% In the lecture, paper proof of type safety for System F using logical relation.
% In general, paper proof is prone to mistakes, so the project was to implement
% the logical relation in Coq.
% System F with unit and products.

  \begin{block}{Paper proof}
    \begin{itemize}
      \item Type safety System F (with unit and products)
      \item Syntactic method VS logical relations
      \item Paper proof: prone to mistakes
    \end{itemize}
  \end{block}

  \begin{block}{Implementation}
    \begin{itemize}
      \item Stronger guarantees
      \item Representations issues
      \item Improvement and extensions
    \end{itemize}
  \end{block}

\end{frame}

% Table of content
\begin{frame}{Outline}
  \begin{enumerate}
    \item On paper
    \item Implementation
          \begin{itemize}
            \item Nameless binders
            \item Substitution lemma
          \end{itemize}
    \item Extensions
  \end{enumerate}
\end{frame}

% In this section, we highlight the main steps of the proof.
\section{On paper}%
\begin{frame}{SystemF}
  \begin{block}{Type safety with logical relation}
    \begin{enumerate}
      \item any well-typed closed term is in the logical relation
            \[\forall e,\ \ty.\ \typed{\empctx}{e}{\ty} \Rightarrow \lr{\empctx}{e}{\ty} \]
      \item  any term in the logical relation is safe
            \[\forall e,\ \ty.\ \lr{\empctx}{e}{\ty} \Rightarrow \safe(e) \]
   \end{enumerate}

  \end{block}

  \begin{block}{Fundamental Theorem of the Logical Relation}
    For any \((\typed{\tyctx;\exprctx}{e}{\ty})\),
    \[
      \forall \sctx,\ \sfun.\ (\sfun \Mapsto_{P} \exprctx) \Rightarrow \lr{\sctx}{\ty}{\sfun(e)}
    \]
    with $P = \lambda \ty,~e.~ \lr{\sctx}{\ty}{e}$.
  \end{block}
\end{frame}

\section{Implementation}%

\begin{frame}
  \frametitle{Named binders}
  \begin{block}{Excerpt semantics}
    \begin{figure}[ht]

      $x,y \in \mathrm{string}$

      $e ::= x\
      |\ \lam{x}{e}\
      |\ \ldots
      $
      \begin{mathpar}
        \inferH
        {E-App}
        {  }
        { \app{(\lam{x}{e})}{v} \hstep \subst{e}{v}{x}}
        \and
      \end{mathpar}
    \end{figure}
  \end{block}

  \begin{block}{Substitution}
    \begin{itemize}
      \item Hidden in the substitution $\subst{e}{v}{x}$
      \item Capture-avoiding
      \item Equality up-to alpha renaming
    \end{itemize}
  \end{block}

  \begin{center}
    Good for paper, bad for implementation
  \end{center}

\end{frame}

\begin{frame}
  \frametitle{De Bruijn binders}
  \begin{block}{Binders}
    \begin{itemize}
      \item Nameless, unique, canonical representation
      \item Variable points directly to its binder
      \item $k$ is bound to the $k$-th enclosing binder
    \end{itemize}
  \end{block}
  \begin{block}{Example}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Modifications}
  
  \begin{block}{Semantic}
    \begin{figure}[ht]

      $k \in \NN$, $\alpha \in \NN$

      $e ::= \lam{}{e} |\ \ldots$

      $\ty ::= \tyforall{}{\ty} |\ \ldots$

      $\exprctx ::= \empctx\ |\ \ty,\exprctx$

      $\fbox{\typed{\exprctx}{e}{\ty}}$
      \begin{mathpar}
        \inferH
        {T-TAbs-DeBruijn}
        {\typed{(\mathrm{map}~(+1)~\exprctx)}{e}{\ty}}
        {\typed{\exprctx}{\tlam{e}}{\tyforall{}{\ty}}}
        \and
      \end{mathpar}
    \end{figure}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Substitution lemma}
  \begin{block}{Block}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Generalized substitution lemma}
  \begin{block}{Block}
  \end{block}
\end{frame}

\section{Extensions}%

\begin{frame}
  \frametitle{Iris}
  \begin{block}{Iris}
  \end{block}
  % \begin{block}{Recursive types}
  %   \begin{itemize}
  %     \item $\tau ::= \ldots\ |\ \mu \alpha. \tau$
  %     \item $\mu$ is a fixpoint operator
  %     \item Breaks normalization
  %   \end{itemize}
  % \end{block}

  % \begin{block}{Reference types}
  %   \begin{itemize}
  %     \item $\tau ::= \ldots\ |\ \text{ref } \tau$
  %     \item Landin's knot: encode the recursion through the heap
  %     \item Breaks normalization
  %   \end{itemize}
  % \end{block}
\end{frame}

\begin{frame}
  \frametitle{Properties}
  \begin{block}{Normalize}
  \end{block}

  \begin{block}{Contextual equivalence}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Conclusion}
\end{frame}

\end{document}
