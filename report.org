#+title: Formalizing SystemF type safety with logical relation in Coq
#+AUTHOR: June Rousseau
#+OPTIONS: toc:nil
#+LATEX_COMPILER: lualatex
#+LATEX_HEADER: \usepackage{pftools}
#+LATEX_HEADER: \usepackage{circledsteps}
#+LATEX_HEADER: \newcommand{\link}[1]{\href{#1}{\cstep}}
#+LATEX_HEADER: \newcommand{\unit}{\text{unit}}
#+LATEX_HEADER: \newcommand{\unitt}{\text{tt}}

#+LATEX_HEADER: \newcommand{\lrp}[2]{\llbracket #2 \rrbracket_{#1}}
#+LATEX_HEADER: \newcommand{\lr}[3]{\llbracket #2 \rrbracket_{#1}(#3)}
#+LATEX_HEADER: \newcommand{\lrv}[2]{\lr{#1}{#2}{v}}
#+LATEX_HEADER: \newcommand{\typed}[3]{#1 \vdash #2 : #3}
#+LATEX_HEADER: \newcommand{\hstep}{\rightsquigarrow}
#+LATEX_HEADER: \newcommand{\step}{\rightarrow}
#+LATEX_HEADER: \newcommand{\mstep}{\step^{\ast}}
#+LATEX_HEADER: \usepackage{syntaxColor}
#+LATEX_HEADER: \input{macros}
\begin{abstract}
Milner wrote "Well-typed does not go wrong". Type safety is a language property
that ensure that if a program is well-typed, it is safe to execute, ie. it will
not be stuck.
Logical relations are a proof method that have been efficient to prove
language properties, such as type safety.
During the lecture in class, we have defined and used a logical relation as a
proof method in order to prove the type safety of SystemF.
Everything on paper, and we assumed some intermediate lemmas. Some data
structures and encoding remained implicit. If one wants to have full trust on a
proof, we want to explicit every minutes details and prove every lemma used.
Proof-assistant as Coq helps to track each of them and make sure that every
proof goal is proved.
The project consists on implementing the logical relation in Coq and prove the
type safety of SystemF using the logical relation.
\end{abstract}
#+TOC: headlines 2

* Introduction
Type safety --- also known as /type soundness/ --- is a language property
ensuring that well-typed terms will never reach a stuck state. A naive approach
to prove type safety of a language is to proceed by induction on the structure
of type. However, this approach fails, because the induction hypothesis is too
weak.
In the literature, type safety is commonly proved using two auxiliary lemmas
known as /progress/ and /preservation/ (citations?). The former says that if an
expression is well-typed, it is either a value, or it can perform a step. The
later says that if an expression is well-typed, the next step will also be
well-typed.
Another way to prove type safety of SystemF is based on logical relation techniques.
Logical relation is a proof method that scales better on more expressive
language (*TODO CHECK?*) and that can be used to prove others language
properties, such as normalization, contextual equivalence or non-interference.
Moreover, the fundamental theorem of logical relation has useful consequences
besides type safety.

Defining logical relation on paper requires to keep track of plenty of minute
details. It is easy to miss an important detail, or to badly assume a lemma on
the relation. In order to get more confidence in our proof, one can use computer
proof-assistant, such as Coq, to help keeping track of all these details.

This report is organized as follows:
In section 2, we formalize the language SystemF (semantic and typing judgment),
the type safety property, the logical relation and we establish the main
theorem. In section 3, we present the different implementation options, and we
highlight the challenges of the implementation in Coq, contrasting with the
paper version of the proof. Finally in section 4, we present
improvement and alternatives of the implementation of the logical relation in
Coq, as well as possible extensions of the project.

The Coq implementation is available online:
https://github.com/BastienRousseau/Logrel_SystemF.
We use circled numbers to link directly to corresponding Coq formal statements
in the following.

* Type safety of SystemF on paper
In this section, we formalize on paper the language SystemF as it has been
implemented in Coq. We present the call-by-value (CBV) small-step semantic and
the typing judgment. Then, we formalize the type safety, the logical relation
and we establish the main theorems.
Most of the formalization is classic, mainly inspired by [Amin lecture notes]
but we adapted it in order to correspond to the Coq implementation.

** Language
\input{figures/syntaxSF1}
The language we consider is a variant of SystemF, that includes
the unit type and the product type with the projection.
In figure \ref{fig:opsemSF1}, we define the syntax and the operational semantic
of the language we use in this project. The reader may notice that the
expression variable are named binders represented as strings. In section 3, we
will see another representation of the binder, based on De Bruijn technique, and
we will explain why the named representation is not the best for the
implementation.

The semantic is a small-step semantic with a call-by-value strategy.
The notation $\subst{e}{v}{x}$ is the capture-avoiding substitution of the expression
variable $x$ by the value $v$. The syntax and the semantic are standard.
We note $\hstep$ the transitive closure of the non-head reduction relation.

\input{figures/typingSF1}
Figure \ref{fig:typingSF1} shows the types and the typing rules of SystemF.
We note $\typed{\tyctx;\ \exprctx}{e}{\ty}$ the typing judgment saying that
"$e$ is of type $\ty$ under the typing context $\tyctx;\ \exprctx$".
$\exprctx$ is the context of expression variables, that associate to each
expression variable its type. $\tyctx$ is the context of type variable, that
gathers the free type variables. $\empctx$ is the empty context. Because the
typing rules are standard, we will not extend the explanation too much.

With the language defined, we can focus on a property of this language, the type
safety.

** Type safety and logical relation
*** Type safety
A term is safe if, for any step it can perform (according to the operational
semantic), it does not get stuck. In other words, any expression it can reduced to
is either a value, or an expression that can do another step.
\[
\safe(e) \eqdef
\forall e'.~e \mstep e' \Rightarrow (e' \in \val) \vee \exists e''.~e' \hstep e''
\]
We can also parameterize the safety predicate by a predicate $P$ on the values, such
that the reduced expression is either a value that respect the predicate
$P$, or it can do an additional step.
Formally, the parameterized safety predicate:
\[
\safe_{P}(e) \eqdef
\forall e'.~e \mstep e' \Rightarrow (e' \in \val \wedge P(v)) \vee \exists e''.~e' \step e''
\]

The *type safety* of a language says that, as soon as a closed term is
well-typed, the term is safe.
\[\forall e,~\ty.~\typed{\empctx}{e}{\ty} \Rightarrow \safe(e) \]

*** Logical relation
As explained in Section 1, we can prove type safety of SystemF using progress
and preservation, but in our case, we use logical relation.
We note the logical relation $\lr{\sctx}{\ty}{v}$. $\sctx$ is a mapping from
type variable to an expression property $P \in (\mathrm{expr} \rightarrow \PP)$
\[\sctx ::= \empctx\ |\ (\alpha \mapsto P) :: \sctx\]

We define the logical relation by induction on the structure of type in Figure \ref{fig:logrelSF}.
\input{figures/logicalrelationSF}

The proof method based on logical relation decompose the type safety theorem in
two lemmas:
1. a term that is well-typed is in the logical relation
\[\forall e,\ \ty.\ \typed{\empctx}{e}{\ty} \Rightarrow \lr{\empctx}{e}{\ty} \]
2. a term in the logical relation is safe
\[\forall e,\ \ty.\ \lr{\empctx}{e}{\ty} \Rightarrow \safe(e) \]

The second lemma is almost trivial, because the safety is basically baked in the
logical relation itself.
The first lemma is however the interesting part of the proof. In order to prove
it, we first need to generalized the lemma.
The generalized version is the so called *Fundamental Theorem of Logical
Relation* (FTLR).

To define the FTLR, we first need to introduce the semantic substitution.
We note $\sfun$ a substitution, which maps expression variables to
expressions.
\[\sfun ::= \empctx\ |\ (x \mapsto e) :: \sfun\]

We say that the substitution $\sfun$ satisfies the typing context $\exprctx$ for
the predicate $P \in \mathrm{type} \rightarrow \mathrm{expr} \rightarrow \PP$, written $\sfun
\Mapsto_{P} \exprctx$, if for all
variables\footnote{We assume that the domain of $\sfun$ and $\exprctx$ are equals.}
in $\sfun$, the predicate $P$ holds for the mapped expression and their
corresponding type in $\exprctx$.

The *FTLR* states that if a closed term is well-typed, then for all substitution
$\sfun$ that satisfies the typing context $\exprctx$ for the logical relation, then the
term under the substitution $\sfun$ is in the logical relation.
\[\forall e,\ \ty,\ \tyctx,\ \exprctx.\ \typed{\tyctx;\exprctx}{e}{\ty} \Rightarrow
(\forall \sctx,\ \sfun.\ (\sfun \Mapsto_{P} \exprctx) \Rightarrow \lr{\sctx}{\ty}{\sfun(e)}) \]
with $P = \lambda \ty,~e.~ \lr{\sctx}{\ty}{e}$.

We highlight some important intermediate lemmas, and we let the reader refer to
the Coq implementation or (Amin's lecture notes) for more details on the proof.

**** Safe mono
For any value predicates P and Q, and any expression e, the Safe predicate is
monotone over the parameterized predicate
\[ (\forall v.\ P(v) \Rightarrow Q(v)) \Rightarrow \safe_{P}(e) \Rightarrow \safe_{Q}(e) \]
**** Safe val
For any value predicates P that holds for a value v, the Safe predicate also
holds.
\[ P(v) \Rightarrow \safe_{P}(v) \]
**** Safe step
For any expression e that steps to an expression e', the Safe predicate backward
propagate for any value predicate P.
\[ e \step e' \Rightarrow \safe_{P}(e') \Rightarrow \safe_{P}(e)\]
**** Safe bind
To prove that an expression $E[e]$ is Safe, it actually suffices to show that
$E[v]$ is safe for any value v.
\[\forall P\ Q\ e,\ \safe_{Q}(e) \Rightarrow
(\forall v,\ Q(v) \Rightarrow \safe_{P}(\ctxh{v})) \Rightarrow
\safe_{P}(\ctxh{e})) \]
**** Logrel subst
*TODO*

\[ \lrv{\sctx}{\ty.[\ty'/\alpha]} \Leftrightarrow \lrv{(\alpha \mapsto \lrp{\sctx}{\ty'})::\sctx}{\ty} \]

**** Logrel weaken
If $\alpha$ is not free in $\ty$, we can associate any predicate $P$ to $\alpha$ in $\sctx$
\[ \lrv{\sctx}{\ty} \Leftrightarrow \lrv{(\alpha \mapsto P)::\sctx}{\ty} \]

*** Free theorems
The FTLR has other consequences than just type safety. It can also be used to
derive free theorems, /à la/ Wadler (cf. Theorem for free).
We prove the two following theorems:
- any polymorphic expression that is typed with the identity type
  $\tyforall{\alpha}{\tyarrow{\alpha}{\alpha}}$
  is indeed the identity function, \ie if we apply the expression to a value
  $v$, it will reduce the value $v$ itself\footnote{If it terminates}.
  \[\forall e~,v.~\typed{\empctx;\empctx}{e}{\tyforall{\alpha}{\tyarrow{\alpha}{\alpha}}}
  \Rightarrow \safe_{(\lambda e.~e = v)}(\app{(\tapp{e})}{v})
  \]
- any polymorphic expression that is typed with the type $\tyforall{\alpha}{\alpha}$ is actually
  the empty type, which is indeed uninhabited.
  \[\forall e~,v.~\typed{\empctx;\empctx}{e}{\tyforall{\alpha}{\alpha}}
  \Rightarrow \safe_{(\lambda e.~\bot )}(\tapp{e})
  \]

* Implementation in Coq
In this section, we describe the different implementations options that we had
and we explain the choices that we made.

*TODO* introduction about the data structure that are implicit (for most of
them), their properties are assumed, etc. But when implement, we need to
concrete data structure and concrete lemmas about them etc.

** SystemF (evaluation context)
The operational semantic of SystemF follows a call-by-value evaluation strategy,
small step semantic.
We had in mind two possible solutions to implement SystemF CBV.
1. A semantic that explicit every single rule: for each expression, we define a
   rule that describes its reduction.
2. A semantic in two steps: a head reduction relation, which expresses how to
   reduce the relation when the redex is in head position; and a non-head
   reduction relation, when the redex is not is the head position. The
   evaluation context determine where the redex is in the term.

The two semantics are equivalent (cf. proof), and both implementations have
their own pros and cons.
The main characteristic that will be help to do the choice is the
the /safe-bind/ lemma :
\[\forall P\ Q\ e,\ \safe_{Q}(e) \Rightarrow
(\forall v,\ Q\ v \Rightarrow \safe_{P}(\ctxh{v})) \Rightarrow
\safe_{P}(\ctxh{v})) \]

On the one hand, the structural induction is easier when the semantic describes
every single rules (1), but we have to prove an equivalent version of the
/safe-bind/ lemma on the fly for each induction case in the fundamental theorem.
On the other hand, the evaluation context semantic (2) is convenient to define
the /safe-bind/ lemma, but the induction cases are more tedious to use. Indeed,
small-step semantic with evaluation context has two reduction relations: in
particular, the non-head reduction relation requires us to destruct the context.

*TODO* we want to stick to the lecture note as much as possible. Better for
improvement cf next section.
In the end, we used the second semantic to focus on the implementation of the
logical relation, as well as the intermediate lemmas.

** Binders (autosubst)

Our first attempt to represent the binding was to implement them using strings.
The advantage of representing the binder using strings is that it makes the
proof --- especially on paper --- more readable.
However, this representation tends to induces some issues because the terms are
equals "up-to renaming of bound variable", and the substitution has to be
capture avoiding.
Moreover, we need to define the parallel (or simultaneous) substitution at some
point, and use this definition to do Coq proof, which is a pain to work with
when defined using strings.

Because the binder representation using string is not satisfactory when
implementing the language in Coq, we had to explore other binding
representations. The question of the implementation of binders is a well-known
issue when implementing a language (cf. TAPL). A solution is the DeBruijn
representation of the binders. It is a canonical, unique and nameless
representation of the binder, in which a variable points directly to its binder:
the named variables are replaced by a natural number that express the distance
to its binder. More precisely, the DeBruijn index k points to the k-th enclosing
\lambda.

In a more formal way, an expression can be a variable $k \in \NN$. A variable k is
free when it ranges outside of the enclosing \lambda.
The notation $\subst{e}{v}{}$ is the substitution of the /first/ free variable: it
replaces the free variable 0, and rename all the other variable consequently.
For instance, in the expression $\subst{\pair{0}{1}}{\tt}{} = \pair{\tt}{0}$,
the first free variable is 0, thus it replaces 0 by the expression $\tt$.
Moreover, the next free variable 1 is then renamed to 0. In the expression
$\subst{1}{\tt}{} = 0$, the first free variable should be 0 (even if it does not
appears in the expression), thus the substitution only perform the renaming.
Finally, when there is lambda abstraction like in the expression,
$\subst{(\lam{}{\pair{0}{\pair{1}{2}}})}{\tt}{} =
(\lam{}{\pair{0}{\pair{\tt}{1}}})$, the substitution replaces the first free
variable under the lambda abstraction and the renaming as well.
*TODO should i write the formal definition of substitution ?*.
In a similar way than the variable of the language, the type variable $\alpha \in \NN$
use the DeBruijn representation.

\input{figures/syntaxDB}
Figure \ref{fig:opsemDB} shows the modifications on the syntax. As type variable
are also represented using the De Bruijn indices, the free variable are the $\alpha$
that range outside the $\forall$. Thus, there is no need to maintain the type variable
context $\tyctx$. Moreover, the expression variable context becomes a sequence of
type, such that the k-th element of the sequence $\exprctx$ is the type of the
free expression variable represented by $k$.

The main modification is in the rule \ruleref{T-TAbs-DeBruijn}
Indeed, in the rule \ruleref{T-Abs} with named binders, the binder of the type
variable $\alpha$ is added in the context, and makes sure that $\alpha$ does not appear
freely in the context $\exprctx$. If necessary, $\alpha$ can be renamed to a fresh type
variable.
Using De Bruijn representation, the new binder is represented by the type
variable 0. All the type variables in the context $\exprctx$ have to be renamed: it
both ensures that the type points to the right binder and the freshness of the
new binder. The renaming consists on incrementating of the (free?) variable
by 1, because they are now under one $\forall$.

The De Bruijn technique has been widely used to represent binders. /autosubst/
is a Coq library that helps to implement and automatize the DeBruijn
representation, and automatically derive and prove some basic lemma about the
(parallel substitution). Moreover, it provides useful tactics to reason with
the substitution operation.

Our implementation uses /autosubst/ to represent the binders and leverage the
automation to simplify the proofs, in particular for the substitution lemma and
the weakening lemma.

\input{figures/logrelDB}
Figure \ref{fig:logrelDB} highlights the modifications of the logical relation
according to the De Bruijn representation of the binders. In particular, we
notice that the mapping $\sctx$ is a sequence of expression properties instead of a
mapping of type variables. Indeed, as we have already done with the context
$\Gamma$, the k-th element of $\sctx$ is the property mapped to the type variable $k$.

*TODO* Example of lemma that was hard to prove with named binders, but easier
with autosubst ?

** Substitution lemmas
One of the main property of the logical relation is the following /substitution
lemma/.
We recall the substitution lemma below, with the De Bruijn representation of the binders
\[
\forall \sctx,\ \ty,\ \ty',\ v.\
\lrv{\sctx}{\subst{\ty}{\ty'}{}}
\Leftrightarrow
\lrv{(\lrp{\sctx}{\ty'}::\sctx)}{\ty}
\]
It states that a value $v$ is in the logical relation for the type
$\ty.[\ty'/]$ if and only if we can associate its own logical relation to the
corresponding free type variable in the interpretation mapping.
However, while the string representation of the binder allows to
proceed by straightforward induction on $\ty$ (?), we cannot proceed directly
by induction with our representation based on the DeBruijn indices. The
induction hypothesis is actually not strong enough. Indeed, the polymorphic type
case does not work.

Let the induction hypothesis be
\[
\forall \sctx,\ \ty,\ \ty',\ v.\
\lrv{\sctx}{\subst{\ty}{\ty'}{}}
\Leftrightarrow
\lrv{(\lrp{\sctx}{\ty'}::\sctx)}{\ty}
\]
The proof obligation for the polymorphic case is
\[
\lrv{\sctx}{\subst{(\tyforall{}{\ty})}{\ty'}{}}
\Leftrightarrow
\lrv{(\lrp{\sctx}{\ty'}::\sctx)}{\tyforall{}{\ty})}
\]
If we unfold the definition of the logical relation,
the proof obligation roughly ends up to look like
\[
\lrv{P::\sctx}{\subst{\ty}{\ty'}{}}
\Leftrightarrow
\lrv{P::(\lrp{\sctx}{\ty'}::\sctx)}{\ty}
\]
where an additional predicate $P$ is the head of the mapping $\sctx$.
While we would like to use the IH, it is not possible because the head of the
mapping has to be the property of the substituted type variable $\ty'$.

The solution is then to generalized the substitution lemma, such that the
predicate that maps the substituted type variable $\ty'$ to the logical relation
may be anywhere in the new mapping. From a higher level, it means that had
already gone through a certain number of type abstraction.


\[
\forall \sctx_{1},\ \sctx_{2},\ \ty',\ v.\
\lrv{ \sctx_{1}++\sctx_{2}}{\subst{\ty}{\mathrm{upn}\ (\mathrm{len }\ \sctx_{1})\ \ty'}{}}
\Leftrightarrow
\lrv{ \sctx_{1}++( \lrp{\sctx_{2}}{\ty'} ::\sctx_{2})}{\ty}
\]
where $\subst{\ty}{\mathrm{upn}\ (\mathrm{len }\ \sctx_{1})\ \ty'}{}$
substitutes $\ty'$ in the type $\ty$ by renaming the variables after
$(\mathrm{len }\ \sctx_{1})$.
It suffices to instantiate the generalized theorem with $\sctx_{1} = \empctx$
to get the substitution lemma.

With a similar argument, the weakening lemma also need a generalization to be proved.

* Possible improvement / Future work
In this section, we discuss about different way in which the project could be
improved. Firstly, we propose an amelioration to make the implementation more
general (?) and modular. Then, we propose some extension of the project.
Finally, we propose an alternative way to implement a logical relation for type
safety in Coq, which could lead to a convenient way to extend the language with
non-trivial features.

** Language independent lemmas
The main interest of the project was to implement type safety of SystemF in Coq,
using logical relation. In Section 2.2, we defined the Safe (parameterized)
predicate and few intermediate lemmas about this predicate. The attentive reader
may have notice that the Safe predicate does not really depends on the language,
on the contrary to the logical relation.

We propose to make the implementation more generic and modular, such that we can
define the Safe predicate independently to the language. In a Coq
implementation, this result in the definition of a class that express what is a
valid language. A generic language is a tuple of:
- the type of expression of the language $\mr{Expr}$
- a function $\mr{is\_value}: \mr{Expr} \rightarrow \PP$ that express which expressions are the
  values of the language
- a function $\mr{head\_step}: \mr{\mr{Expr}} \rightarrow \mr{Expr} \rightarrow \PP$ that express
  the head reduction relation
- a function $\mr{is\_ectx}: (\mr{Expr} \rightarrow \mr{Expr}) \rightarrow \PP$ that express how to
  determine the evaluation context when the redex is not in head position

The future work is to determine which properties (expressed in terms of the
generic) are necessary to make the language a /valid/ language.
By valid language, we mean a language that allows one to derive the properties
over the Safe predicate, \ie safe-mono, safe-val, safe-bind and safe-step.

This improvement brings more modularity in the implementation. One can indeed
define its own language, prove that the language is a valid language and the
typeclass derives automatically the Safe predicates for free.
Of course, our variant of SystemF would be an instance of such valid language.
But we could easily extend the project with type safety of another language,
such as Simply Typed Lambda Calculus (STLC) without proving the properties of
Safe again.

** Other language properties
As mentioned earlier, logical relation is a proof technique that can be used to
prove language properties. The properties we focused on in this project is type
safety. We propose two others properties to extend the project.
*** Normalization
A term normalizes if it reduces to a value. Formally,
\[\norm(e) \eqdef \exists v \in \val.~e \step^{*} v\]
and the parameterized version
\[\norm_{P}(e) \eqdef \exists v \in \val.~e \step^{*} v \wedge P(v)\]

We can derive the lemmas equivalent to Safe-val, Safe-mono, Safe-bind and
Safe-step for the Norm predicate. This extension could leverage the modularity
of the previous proposition.

*** Contextual equivalence
Contextual equivalence, or observational equivalence, is a language property
saying that, if two program are contextually equivalent, there does not exist
any context able to differentiate the them. It is also a way to derive free
theorems.

Formally, the contextual equivalence is defined as follows:
\[
\typed{\tyctx';\exprctx'}{e_{1} \approx^{\mathrm{ctx}} e_{2} }{\ty'}
\eqdef
 \forall \ctx\ :\ (\tyctx;\exprctx \vdash \ty) \Rightarrow (\empctx;\empctx \vdash \tyunit).\
 (\ctxh{e_{1}} \Downarrow v \Leftrightarrow \ctxh{e_{2}} \Downarrow v)
\]
where $e \Downarrow v \eqdef e \mstep v$ and 
\begin{mathpar}
\inferH
{Ctx-Typing}
{\typed{\tyctx;\exprctx}{e}{\ty}
\\
\typed{\tyctx';\exprctx'}{\ctxh{e}}{\ty'}
}
{ \ctx~:~(\tyctx;\exprctx \vdash \ty) \Rightarrow (\tyctx';\exprctx' \vdash \ty')}
\end{mathpar}

It states that two expressions $e_{1}$ and $e_{2}$ of type $\ty$ are contextually
equivalent if and only if
for any context that has a hole of type $\ty$, and produces a closed expression of
type $\tyunit$ (see \ruleref{Ctx-Typing}), filling the hole with $e_{1}$ or $e_{2}$
will both reduces to the same value $v$ (which actually has to be $\tt$).


** Logical relation using Iris
Iris is a higher-order separation logic framework, implemented and verified in
Coq. Iris as been shown to be an efficient framework to implement logical
relation. In particular, an alternative way to implement the logical relation
and prove type soundness of SystemF could have been to use the Iris framework.

An extension of SystemF is to add recursive types. However, literature has shown
that adding recursive types is a feature that lead to a non-trivial extension of
the logical relation: indeed, we have defined the logical relation inductively
on the structure of type, but unfolding a recursive type does not guarantee the
resulting type to be smaller than the folded one. Thus, it is impossible to
simply extend the logical relation defined in this project.
Similarly, another extension of the language is to add pointer, which leads to a
similar issue (we can encode the recursion through the heap, thanks to the
Landin's knot technique).

However, Iris is a step-indexed logic. It provides the logical tools to easily
manage the recursive types. Moreover, because Iris is a logic of resources, it
allows to define the resources of heap and easily implement the pointers.

* Conclusion


* Ideas :noexport:
** SystemF type safety with logical relation
    As we have seen in the lecture
** Formalize directly Amin's lecture note from the lecture
** Use strings to represent the binders as a first step
But the simultaneous substitution was a pain to work with
** Replace string binders with De Bruijn binders, using autosubst
** Remaining work
- Bunch of intermediate lemmas about substitution to prove
- Main type safety theorem
- Free theorems ?
