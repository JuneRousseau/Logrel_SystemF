# -*- citar-bibliography: ("./biblio.bib"); -*-
#+title: Formalizing SystemF type safety with logical relation in Coq
#+AUTHOR: June Rousseau
#+OPTIONS: toc:nil
#+LATEX_COMPILER: lualatex
#+LATEX_HEADER: \usepackage[usenames,dvipsnames]{xcolor}
#+LATEX_HEADER: \usepackage{pftools}
#+LATEX_HEADER: \usepackage{circledsteps}
#+LATEX_HEADER: \newcommand{\link}[1]{\href{#1}{\cstep}}
#+LATEX_HEADER: \newcommand{\unit}{\text{unit}}
#+LATEX_HEADER: \newcommand{\unitt}{\text{tt}}

#+LATEX_HEADER: \newcommand{\lrp}[2]{\llbracket #2 \rrbracket_{#1}}
#+LATEX_HEADER: \newcommand{\lr}[3]{\llbracket #2 \rrbracket_{#1}(#3)}
#+LATEX_HEADER: \newcommand{\lrv}[2]{\lr{#1}{#2}{v}}
#+LATEX_HEADER: \newcommand{\typed}[3]{#1 \vdash #2 : #3}
#+LATEX_HEADER: \newcommand{\hstep}{\rightsquigarrow}
#+LATEX_HEADER: \newcommand{\step}{\rightarrow}
#+LATEX_HEADER: \newcommand{\mstep}{\step^{\ast}}
#+LATEX_HEADER: \usepackage{syntaxColor}
#+LATEX_HEADER: \input{macros}
#+LATEX_HEADER: \usepackage{amsthm}
#+LATEX_HEADER: \theoremstyle{plain}
#+LATEX_HEADER: \newtheorem*{theorem*}{Theorem}
#+LATEX_HEADER: \newtheorem*{lemma*}{Lemma}
#+LATEX_HEADER: \newtheorem*{definition*}{Definition}
#+LATEX_HEADER: \usepackage{todonotes}
#+bibliography: biblio.bib
\begin{abstract}
Type safety is a language property that ensure that if a program is well-typed,
this program is safe to execute. While syntactic approaches have been widely
used to prove type safety, another proof method based on logical relation has
been shown to be efficient to prove such language properties.
During the lecture, we have defined, on paper, a logical relation
and used it to prove type safety of SystemF. Because there is many details
paper proof are prone to errors. Moreover, the encoding of some
data structures, as well as their properties, are often implicits.
Proof-assistant as Coq requires to explicit everything in the implementation,
prove every single properties, and helps to keep track of every minute details.
To fill the gap between paper proof and a proof-assistant implementation, we
propose an implementation in Coq of type safety of SystemF, using logical
relation.
\end{abstract}
#+TOC: headlines 2

\todo{On the document, we use "term" and "expression" interchangeably}
* Introduction
:PROPERTIES:
:CUSTOM_ID: introduction
:END:
Milner wrote /"Well-typed programs cannot go wrong"/
[cite:@milnerTheoryTypePolymorphism1978].
Type safety --- also known as /type soundness/ --- is a language property
ensuring that well-typed program are safe. More precisely, it means that any
well-typed closed term of the language will never reach a state in which the
semantic says nothing.
A naive approach to prove type safety of a language would be is to proceed by
induction on the structure of type. However, this approach fails because the
induction hypothesis is too weak.
Type safety is commonly proved using two auxiliary lemmas known as /progress/
and /preservation/
[cite:@wrightSyntacticApproachType1994; @pierceTypesProgrammingLanguages2002].
Informally, the former states that a well-typed expression is not stuck, \ie it
is either a value, or can perform a step. The later says that if an expression
is well-typed, the next step will also be well-typed.
Another way to prove type safety is based on logical relation. Logical relation
is a proof method that scales better on more expressive language
\todo{check this information}
and that can be used to prove others language properties, such
as normalization, contextual equivalence or non-interference. Moreover, the
fundamental theorem of logical relation has consequences besides type safety.

When defining a logical relation, there is plenty of detail to keep track, which
makes the paper proof prone to miss an important detail. Moreover, the concrete
data structure are sometimes quite implicit. Proof assistant, such as Coq, make
sure that every single properties has been proved. The interactive theorem
prover helps one to keep track of every minute detail. Thus, implementing
logical relation to prove type safety in Coq \todo{find the verb} more
confidence. \todo{However, it requires to make the right implementation choice}

This report is organized as follows.
In section [[#paper-proof]], we formalize on paper the language SystemF, the type
safety property, the logical relation and we establish the main theorems and
lemmas.
In section [[#implementation]], we present the different implementation options, and
we highlight the challenges of the implementation in Coq, contrasting with the
paper version of the proof.
Finally in section [[#improvement]], we propose ideas of improvement and
alternatives of the implementation, as well as possible extensions of the
project.

The Coq implementation is available in a [[https://github.com/BastienRousseau/Logrel_SystemF/tree/release][Github repository online]].
If the following, we use numbered circles to link the formal statement to the
corresponding Coq code\footnote{Some representation details might differ.}.

* Type safety of SystemF on paper
:PROPERTIES:
:CUSTOM_ID: paper-proof
:END:
In this section, we formalize on paper the language SystemF using a named
representation of the binders. We present the call-by-value (CBV) small-step
semantic and the typing judgment. Then, we formalize the type safety, the
logical relation and we formulate the main lemmas and theorem.
Most of the formalization is standard [cite:@timanyLogicalRelationsSafety].

** Language
\input{figures/syntaxSF1}
We consider a variant of the language SystemF, that includes the unit and the
product type.
We define the syntax and the operational semantic of the language
in figure \ref{fig:opsemSF1}.
The named binders are represented as strings. The variable $y$ in the expression
$\pair{\tt}{y}$ is a free variable (not bind to any lambda abstraction), while
the variable $x$ in the expression $\lam{x}{x}$ is bind to the lambda
abstraction. In section [[#implementation]], we will see a different representation
of the binder, based on De Bruijn technique, and we will explain why the named
representation is not the best for the implementation.

The semantic is a small-step semantic with a call-by-value strategy.
The notation $\subst{e}{v}{x}$ is the capture-avoiding substitution of the expression
variable $x$ by the value $v$. We note $\mstep$ the transitive closure of the
non-head reduction relation $\step$. The syntax and the semantic are standard.

\input{figures/typingSF1}
Figure \ref{fig:typingSF1} shows the types and the typing rules of SystemF.
We note $\typed{\tyctx;\ \exprctx}{e}{\ty}$ the typing judgment saying that
/"$e$ is of type $\ty$ under the typing context $\tyctx;\ \exprctx$"/.
$\exprctx$ is the context of expression variables, that associates a type to an
expression variable.
$\tyctx$ is the context of type variable, that gathers the free type variables.
We note $\empctx$ an empty context. The typing rules are also standard.

With the language defined, we can focus on a property of this language, the type
safety.

** Type safety
:PROPERTIES:
:CUSTOM_ID: type-safety
:END:
A term is safe if it never get stuck after any number of step. In other words,
any reduced expression is either a value, or can perform another step.
\begin{definition*}{Safety}
\[
\safe(e) \eqdef
\forall e'.~e \mstep e' \Rightarrow (e' \in \val) \vee \exists e''.~e' \hstep e''
\]
\end{definition*}
A weaker version of the safety is the parameterized safety. Let $P$ a predicate
of values. A term is safe according to $P$ if any reduced expression can either
perform a step, or is a value that \todo{respects} the predicate $P$.
\begin{definition*}{Parameterized safety
\href{https://github.com/BastienRousseau/Logrel_SystemF/blob/599b9e84d6d8f902442e5f85f37522ce21708103/theories/logrel.v#L37}{\cstep}
}
\[
\safe_{P}(e) \eqdef
\forall e'.~e \mstep e' \Rightarrow (e' \in \val \wedge P(v)) \vee \exists e''.~e' \step e''
\]
\end{definition*}
A language is type safe as soon as any closed well-typed term is safe.
\begin{theorem*}{Type safety
\href{https://github.com/BastienRousseau/Logrel_SystemF/blob/599b9e84d6d8f902442e5f85f37522ce21708103/theories/logrel.v#L526}{\cstep}
}
\(\forall e,~\ty.~\typed{\empctx}{e}{\ty} \Rightarrow \safe(e)\)
\end{theorem*}

** Logical relation
As pointed out in Section [[#introduction]], type safety of SystemF can be proved
using the syntactic approach of progress and preservation
[cite:@wrightSyntacticApproachType1994], but can also be proved using logical
relation.
We note the logical relation[fn::We can also say /"$v$ is in the logical
relation for the type $\ty$"/]
$\lr{\sctx}{\ty}{v}$, where \(\sctx ::= \empctx\ |\ (\alpha \mapsto P) :: \sctx\) is
a mapping from type variable to an expression property
$P \in (\mathrm{Expr} \rightarrow \PP)$.

We define the logical relation by induction on the structure of type in Figure \ref{fig:logrelSF}.
\input{figures/logicalrelationSF}

With the logical relation, the type safety theorem is the composition of two
lemmas:
1. any closed well-typed term is in the logical relation
   \[\forall e,\ \ty.\ \typed{\empctx}{e}{\ty} \Rightarrow \lr{\empctx}{e}{\ty} \]
2. any term in the logical relation is safe
   \[\forall e,\ \ty.\ \lr{\empctx}{e}{\ty} \Rightarrow \safe(e) \]

The second lemma is very straightforward, because the safety is basically baked
in the logical relation itself.
The first lemma is the interesting part of the proof. In order to prove it, we
first need to generalized the lemma. The generalized version is the *Fundamental
Theorem of Logical Relation* (FTLR).

To define the FTLR, we first need to introduce the semantic substitution.
We note $\sfun$ a substitution, which maps expression variables to
expressions.
\[\sfun ::= \empctx\ |\ (x \mapsto e) :: \sfun\]

We say that the substitution $\sfun$ satisfies the typing context $\exprctx$ for
the predicate $P \in \mathrm{Type} \rightarrow \mathrm{Expr} \rightarrow \PP$, written
$\sfun \Mapsto_{P} \exprctx$, if for all
variables[fn::We assume that the domain of $\sfun$ and $\exprctx$ are equals.]
in $\sfun$, the predicate $P$ holds for the mapped expression and their
corresponding type in $\exprctx$.
\begin{definition*}{Typing context satisfaction
\href{https://github.com/BastienRousseau/Logrel_SystemF/blob/599b9e84d6d8f902442e5f85f37522ce21708103/theories/logrel.v#L132}{\cstep}
}
\[
\sfun \Mapsto_{P} \exprctx \eqdef \forall x \in \mr{Dom}(\sfun).~P(\sfun(x))(\exprctx(x))
\]
\end{definition*}

The FTLR states that if a closed term is well-typed, then for all substitution
$\sfun$ that satisfies the typing context $\exprctx$ for the logical relation, then the
term substituted with $\sfun$ is in the logical relation.
\begin{theorem*}{Fundamental Theorem of Logical Relation
\href{https://github.com/BastienRousseau/Logrel_SystemF/blob/599b9e84d6d8f902442e5f85f37522ce21708103/theories/logrel.v#L394}{\cstep}
}
\[\forall e,\ \ty,\ \tyctx,\ \exprctx.\ \typed{\tyctx;\exprctx}{e}{\ty} \Rightarrow
(\forall \sctx,\ \sfun.\ (\sfun \Mapsto_{P} \exprctx) \Rightarrow \lr{\sctx}{\ty}{\sfun(e)}) \]
with $P = \lambda \ty,~e.~ \lr{\sctx}{\ty}{e}$.
\end{theorem*}

In the end of the section, we highlight some important intermediate lemmas.
We let the reader refer to the Coq proof, or the lecture notes
[cite:@timanyLogicalRelationsSafety] for the paper proof.

For any value predicates $P$ and $Q$, and any expression $e$, the $\safe$
predicate is monotone over the parameterized predicate.
\begin{lemma*}{Safe monotonicity
\href{https://github.com/BastienRousseau/Logrel_SystemF/blob/599b9e84d6d8f902442e5f85f37522ce21708103/theories/logrel.v#L41}{\cstep}
}\label{thm:safemono}
\( (\forall v.\ P(v) \Rightarrow Q(v)) \Rightarrow \safe_{P}(e) \Rightarrow \safe_{Q}(e) \)
\end{lemma*}

For any value predicates $P$ that holds for a value $v$, the $\safe$ predicate also
holds.
\begin{lemma*}{Safe value
\href{https://github.com/BastienRousseau/Logrel_SystemF/blob/599b9e84d6d8f902442e5f85f37522ce21708103/theories/logrel.v#L51}{\cstep}
}\label{thm:safeval}
\( P(v) \Rightarrow \safe_{P}(v) \)
\end{lemma*}

For any expression $e$ that steps to an expression $e'$, the $\safe$ predicate
is (backward)-preserved for any value predicate $P$.
\begin{lemma*}{Safe step backward
\href{https://github.com/BastienRousseau/Logrel_SystemF/blob/599b9e84d6d8f902442e5f85f37522ce21708103/theories/logrel.v#L58}{\cstep}
}\label{thm:safestep}
\( e \step e' \Rightarrow \safe_{P}(e') \Rightarrow \safe_{P}(e)\)
\end{lemma*}

To prove that an expression $E[e]$ is $\safe$, it actually suffices to show that
$E[v]$ is safe for any value $v$.
\begin{lemma*}{Safe bind
\href{https://github.com/BastienRousseau/Logrel_SystemF/blob/599b9e84d6d8f902442e5f85f37522ce21708103/theories/logrel.v#L72}{\cstep}
}\label{thm:safebind}
\[\forall P\ Q\ e,\ \safe_{Q}(e) \Rightarrow
(\forall v,\ Q(v) \Rightarrow \safe_{P}(\ctxh{v})) \Rightarrow
\safe_{P}(\ctxh{e})) \]
\end{lemma*}

The logical relation of the substitution of the type $\ty'$ in a type $\ty$ is equivalent
to associate the logical relation of $\ty'$ to the corresponding free variable
in $\sctx$.
\begin{lemma*}{Logrel subst
\href{https://github.com/BastienRousseau/Logrel_SystemF/blob/599b9e84d6d8f902442e5f85f37522ce21708103/theories/logrel.v#L385}{\cstep}
}
\( \lrv{\sctx}{\ty.[\ty'/\alpha]} \Leftrightarrow \lrv{(\alpha \mapsto \lrp{\sctx}{\ty'})::\sctx}{\ty} \)
\end{lemma*}

If $\alpha$ is not free in $\ty$, we can associate any predicate $P$ to $\alpha$ in $\sctx$.
\begin{lemma*}{Logrel weaken
\href{https://github.com/BastienRousseau/Logrel_SystemF/blob/599b9e84d6d8f902442e5f85f37522ce21708103/theories/logrel.v#L302}{\cstep}
}
\( \lrv{\sctx}{\ty} \Leftrightarrow \lrv{(\alpha \mapsto P)::\sctx}{\ty} \)
\end{lemma*}

** Free theorems
The FTLR has other consequences, besides type safety. For instanc, it can also
be used to derive free theorems, /à la/ Wadler [cite:@wadlerTheoremsFree1989].
We prove the two following theorems.

Any polymorphic expression that is typed with the identity type
$\tyforall{\alpha}{\tyarrow{\alpha}{\alpha}}$ is indeed the identity function, \ie if we apply
the expression to a value $v$, it will reduce the value $v$
itself\footnote{If it terminates}.
\begin{theorem*}{Polymorphic identity
\href{https://github.com/BastienRousseau/Logrel_SystemF/blob/599b9e84d6d8f902442e5f85f37522ce21708103/theories/free_theorem.v#L8}{\cstep}}
\[\forall e~,v.~\typed{\empctx;\empctx}{e}{\tyforall{\alpha}{\tyarrow{\alpha}{\alpha}}}
\Rightarrow \safe_{(\lambda e.~e = v)}(\app{(\tapp{e})}{v})
\]
\end{theorem*}

Any polymorphic expression that is typed with the type $\tyforall{\alpha}{\alpha}$ is actually
the empty type, which is indeed uninhabited.
\begin{theorem*}{Empty type
\href{https://github.com/BastienRousseau/Logrel_SystemF/blob/599b9e84d6d8f902442e5f85f37522ce21708103/theories/free_theorem.v#L35}{\cstep}}
\[\forall e~,v.~\typed{\empctx;\empctx}{e}{\tyforall{\alpha}{\alpha}}
\Rightarrow \safe_{(\lambda e.~\bot )}(\tapp{e})
\]
\end{theorem*}

* Implementation in Coq
:PROPERTIES:
:CUSTOM_ID: implementation
:END:
In this section, we describe the different implementations options that we had
and we explain the choices that we made.

** Data structure :noexport:
introduction about the data structure that are implicit (for most of them),
their properties are assumed, etc. But when implement, we need to concrete data
structure and concrete lemmas about them etc.
** Semantic with evaluation context
The operational semantic of SystemF follows a call-by-value evaluation strategy,
small step semantic.
We had in mind two possible solutions to implement SystemF CBV.
1. A semantic with an explicit reduction rule for every inductive case
    \href{https://github.com/BastienRousseau/Logrel_SystemF/blob/599b9e84d6d8f902442e5f85f37522ce21708103/theories/syntax_systemF.v}{\cstep}:
    we define a single reduction relation which contains all the rules.
2. An evaluation context based semantic in two steps
    \href{https://github.com/BastienRousseau/Logrel_SystemF/blob/599b9e84d6d8f902442e5f85f37522ce21708103/theories/opsem_systemF_ctx.v}{\cstep}:
   a head reduction relation, which expresses how to reduce the expression when
   the redex is in head position; and a non-head reduction relation, when the
   redex is not is the head position. The evaluation context determines where is
   the redex in the term.

The two semantics are equivalent
\href{https://github.com/BastienRousseau/Logrel_SystemF/blob/599b9e84d6d8f902442e5f85f37522ce21708103/theories/opsem_systemF_ctx.v#L131}{\cstep},
and both implementations have their own pros and cons.
On the one hand, the structural induction is easier with the one-step semantic
(1), but the lack of evaluation context prevents to define the /safe bind lemma/
\ref{thm:safebind}. It implies that the binding has to be defined /on-the-fly/
for each induction case of the FTLR.
On the other hand, the evaluation context semantic (2) is convenient to define
the /safe-bind/ lemma, but the proofs by induction tend to be more tedious. The
semantic has indeed two reduction relations: in particular, the non-head
reduction relation requires us to destruct the context.
\todo{is there another way to describe it?}

In the end, both approaches are equivalent (in term of proof effort), and the
choice is mainly a matter of taste. We wanted to stick to the lecture notes
[cite:@timanyLogicalRelationsSafety] as much as possible, we then decided to use
the evaluation context semantic to define the logical relation. Moreover,
we show in section [[#improvement]] another argument that scales in favour of the
evaluation context semantic.

** Nameless binders

In the expression $\lam{x}{e}$, we call $\lambda x$ a /binder/. When an expression
variable is bounded, we says that it points to a specific binder.
Named binders is a way to represent the binder, such that all the occurrences of
$x$ in $\lam{x}{e}$ point to the binder $\lambda x$, until another binder with the
same name appears. It is a convenient way to represent the binders, because the
proofs, especially on paper, are more readable. However, this representation has
also some downsides. Firstly, the same term might have different representation,
because the terms are equals /up-to renaming of the bound variables/. For
instance, $\lam{x}{x}$ represents the same term than $\lam{y}{y}$. Secondly,
we have to make sure that the the substitution is capture-avoiding.
Since the proof are more readable with named binders, we first tried to use them
in the implementation. At some point, we had to define the parallel (or
simultaneous) substitution, and using this definition in the Coq proof was a
pain.

The named representation of the binders is not satisfactory when
implementing the language in Coq. The question of the implementation of binders
is a well-known issue when implementing a language
[cite:@pierceTypesProgrammingLanguages2002]. An alternative solution is
to use the DeBruijn representation. It is a canonical, unique and nameless
representation of the binder. Informally, the variable point directly to their
binder: the named variables are replaced by a natural number that expresses the
distance to its binder. More precisely, the DeBruijn index /k/ points to the
/k/-th enclosing \lambda.

In a more formal way, an expression can be a variable $k \in \NN$. A variable $k$
is free when it ranges outside of the enclosing \lambda.
The notation $\subst{e}{v}{}$ is the substitution of the /first/ free variable: it
replaces the free variable 0 (1 if it enters in a lambda-abstraction, etc), and
renames all the other variable consequently.
For instance, in the expression $\subst{\pair{0}{1}}{\tt}{} = \pair{\tt}{0}$,
the first free variable is 0, thus it replaces 0 by the expression $\tt$.
Moreover, the next free variable 1 is then renamed to 0. In the expression
$\subst{1}{\tt}{} = 0$, the first free variable should be 0 (even if it does not
appears in the expression), thus the substitution only perform the renaming.
Finally, in the expression,
$\subst{(\lam{}{\pair{0}{\pair{1}{2}}})}{\tt}{} =
(\lam{}{\pair{0}{\pair{\tt}{1}}})$, the substitution enters in the
lambda-abstraction, where the first free variable is now represented as 1.
\todo{should i write the formal definition of substitution ?}
In a similar way, the type variable $\alpha \in \NN$ uses the DeBruijn representation.

\input{figures/syntaxDB}
Figure \ref{fig:opsemDB} shows the modifications on the syntax due to the new
representation. As type variable are also represented using the De Bruijn
indices, the free variable are the $\alpha$ that range outside the number of
enclosing $\forall$. Thus, there is no need to maintain the type variable context
$\tyctx$. Moreover, the expression variable context becomes an ordered sequence
of type, such that the /k/-th element of the sequence $\exprctx$ is the type of
the free expression variable represented by $k$.

The main modification is in the rule \ruleref{T-TAbs-DeBruijn}
Indeed, in the rule \ruleref{T-Abs} with named binders, the binder of the type
variable $\alpha$ is added in the context, and makes sure that $\alpha$ does not appear
freely in the context $\exprctx$. If necessary, $\alpha$ can be renamed to a fresh type
variable.
Using De Bruijn representation, the new binder is represented by the type
variable 0. All the type variables in the context $\exprctx$ have to be renamed: it
both ensures that the type points to the right binder and the freshness of the
new binder. The renaming consists on incrementating the free type variable by 1,
because they are now under one $\forall$.

The De Bruijn technique has been widely used to represent binders. /autosubst/
[cite:@SchaeferEtAl:2015:Autosubst:-Reasoning] is a Coq library that helps to
implement and automatize the DeBruijn representation. It automatically derives
and proves some basic lemmas about the (parallel) substitution. Moreover, it
provides useful tactics to reason with the substitution. Our implementation uses
/autosubst/ to represent the binders and leverages the automation to simplify
the proofs, in particular for the substitution lemma and the weakening lemma.

\input{figures/logrelDB}
Figure \ref{fig:logrelDB} highlights the modifications of the logical relation
according to the De Bruijn representation of the binders. In particular, we
notice that the mapping $\sctx$ is a sequence of expression properties instead of a
mapping of type variables. Indeed, as we have already done with the context
$\Gamma$, the \alpha-th element of $\sctx$ is the property mapped to the type variable
$\alpha$.

\todo{Example of lemma that was hard to prove with named binders, but easier with autosubst}

** Substitution lemmas
One of the main property of the logical relation is the /substitution lemma/.
We recall the substitution lemma below, but with the De Bruijn representation of the binders.
\begin{lemma*}{Logrel subst - De Bruijn}
\[
\forall \sctx,\ \ty,\ \ty',\ v.\
\lrv{\sctx}{\subst{\ty}{\ty'}{}}
\Leftrightarrow
\lrv{(\lrp{\sctx}{\ty'}::\sctx)}{\ty}
\]
\end{lemma*}
It states that a value $v$ is in the logical relation for the type
$\ty.[\ty'/]$ if and only if we can associate its own logical relation to the
corresponding free type variable in the interpretation mapping.
However, while the string representation of the binder allows to
proceed by straightforward induction on $\ty$, we cannot proceed directly
by induction with our representation based on the DeBruijn indices.

The induction hypothesis is actually not strong enough, and the inductive case
for the polymorphic type does not work.
Let the induction hypothesis be
\[
\forall \sctx,\ \ty,\ \ty',\ v.\
\lrv{\sctx}{\subst{\ty}{\ty'}{}}
\Leftrightarrow
\lrv{(\lrp{\sctx}{\ty'}::\sctx)}{\ty}
\]
The proof obligation for the polymorphic case is
\[
\lrv{\sctx}{\subst{(\tyforall{}{\ty})}{\ty'}{}}
\Leftrightarrow
\lrv{(\lrp{\sctx}{\ty'}::\sctx)}{\tyforall{}{\ty})}
\]
If we unfold the definition of the logical relation,
the proof obligation roughly ends up to look like
\[
\lrv{P::\sctx}{\subst{\ty}{\ty'}{}}
\Leftrightarrow
\lrv{P::(\lrp{\sctx}{\ty'}::\sctx)}{\ty}
\]
where an additional predicate $P$ is the head of the mapping $\sctx$.
While we would like to use the induction hypothesis, it is not possible because
the head of the mapping has to be the property of the substituted type variable
$\ty'$.

The solution is then to generalized the substitution lemma, such that the
predicate that maps the substituted type variable $\ty'$ to the logical relation
may be anywhere in the new mapping. From a high level, it means that
the induction has already gone through a certain number of type abstraction
$\tyforall{\ty}$.

\begin{lemma*}{Generalized logrel subst - De Bruijn
\href{https://github.com/BastienRousseau/Logrel_SystemF/blob/599b9e84d6d8f902442e5f85f37522ce21708103/theories/logrel.v#L325}{\cstep}
}
\[
\forall \sctx_{1},\ \sctx_{2},\ \ty',\ v.\
\lrv{ \sctx_{1}++\sctx_{2}}{\subst{\ty}{\mathrm{upn}\ (\mathrm{len }\ \sctx_{1})\ \ty'}{}}
\Leftrightarrow
\lrv{ \sctx_{1}++( \lrp{\sctx_{2}}{\ty'} ::\sctx_{2})}{\ty}
\]
where $\subst{\ty}{\mathrm{upn}\ (\mathrm{len }\ \sctx_{1})\ \ty'}{}$
substitutes $\ty'$ in the type $\ty$ by renaming the variables after
$(\mathrm{len }\ \sctx_{1})$.
\end{lemma*}
It suffices to instantiate the generalized theorem with $\sctx_{1} = \empctx$
to get the substitution lemma.

* Possible improvement / Future work
:PROPERTIES:
:CUSTOM_ID: improvement
:END:
In this section, we discuss about different way in which the project could be
improved. Firstly, we propose an amelioration to make the implementation more
generic and modular. Then, we propose some direction in which we could extend
the project.
Finally, we propose an alternative way to implement a logical relation for type
safety in Coq, which could lead to a convenient way to extend the language with
non-trivial features.

** Language typeclass
The main interest of the project was to implement type safety of SystemF in Coq,
using logical relation. In section [[#type-safety]], we defined the
parameterized $\safe$ predicate and few intermediate lemmas about this
predicate. We may notice that the $\safe$ predicate does not really depends on
the language, on the contrary to the logical relation.

We propose to make the implementation more generic and modular, such that we can
define the $\safe$ predicate independently to the language. In a Coq
implementation, this result in the definition of a class that expresses what is a
valid language. A generic language is a tuple of:
- the type of expression of the language $\mr{Expr}$
- a function $\mr{is\_value}: \mr{Expr} \rightarrow \PP$ that expresses which expressions
  are the values of the language
- a function $\mr{head\_step}: \mr{\mr{Expr}} \rightarrow \mr{Expr} \rightarrow \PP$ that expresses
  the head reduction relation
- a function $\mr{is\_ectx}: (\mr{Expr} \rightarrow \mr{Expr}) \rightarrow \PP$ that expresses how to
  determine the evaluation context when the redex is not in head position

The future work is to determine which properties (expressed in terms of the
generic language) are necessary to make the language a /valid/ language.
By valid language, we mean a language that allows one to derive the properties
over the $\safe$ predicate, \ie \href{thm:safemono}{safe-mono},
\href{thm:safeval}{safe-val}, \href{thm:safebind}{safe-bind} and
\href{thm:safestep}{safe-step}.

This improvement brings more modularity in the implementation. One can indeed
define its own language, prove that the language is a valid language and the
typeclass derives automatically the lemmas about the safety for free.
Our variant of SystemF would be an instance of such valid language.
But we could easily extend the project with type safety of another language,
such as Simply Typed Lambda Calculus (STLC) without proving the safety lemmas again.

** Other language properties
As mentioned earlier, logical relation is a proof technique that can be used to
prove language properties [cite:@skorstengaardIntroductionLogicalRelations]. We
propose two others properties to extend the project.
*** Normalization
A term normalizes if it reduces to a value. Formally,
\[\norm(e) \eqdef \exists v \in \val.~e \step^{*} v\]
and the parameterized version
\[\norm_{P}(e) \eqdef \exists v \in \val.~e \step^{*} v \wedge P(v)\]

We can derive the lemmas equivalent to \href{thm:safemono}{safe-mono},
\href{thm:safeval}{safe-val}, \href{thm:safebind}{safe-bind} and
\href{thm:safestep}{safe-step} for the $\norm$ predicate. This extension could
leverage the modularity of the previous proposition.

*** Contextual equivalence
Contextual equivalence, or observational equivalence, is a language property
saying that, if two program are contextually equivalent, it does not exist
any context able to differentiate them. It is also a way to derive free
theorems.

Formally, the contextual equivalence is defined as follows:
\[
\typed{\tyctx';\exprctx'}{e_{1} \approx^{\mathrm{ctx}} e_{2} }{\ty'}
\eqdef
 \forall \ctx\ :\ (\tyctx;\exprctx \vdash \ty) \Rightarrow (\empctx;\empctx \vdash \tyunit).\
 (\ctxh{e_{1}} \Downarrow v \Leftrightarrow \ctxh{e_{2}} \Downarrow v)
\]
where $e \Downarrow v \eqdef e \mstep v$ and 
\begin{mathpar}
\inferH
{Ctx-Typing}
{\typed{\tyctx;\exprctx}{e}{\ty}
\\
\typed{\tyctx';\exprctx'}{\ctxh{e}}{\ty'}
}
{ \ctx~:~(\tyctx;\exprctx \vdash \ty) \Rightarrow (\tyctx';\exprctx' \vdash \ty')}
\end{mathpar}

It states that two expressions $e_{1}$ and $e_{2}$ of type $\ty$ are contextually
equivalent if and only if
for any context that has a hole of type $\ty$, and produces a closed expression of
type $\tyunit$ (see \ruleref{Ctx-Typing}), filling the hole with $e_{1}$ or $e_{2}$
will both reduces to the same value $v$ (which actually has to be $\tt$).

** Logical relation using Iris
Iris [cite:@IrisProject; @jungIrisGroundModular2018] is a higher-order
separation logic framework, implemented and verified in Coq. Iris as been shown
to be an efficient framework to implement logical relation. In particular, an
alternative way to implement the logical relation and prove type soundness of
SystemF [cite:@timanyLogicalApproachType2022] could have been to use the Iris
framework.

A possible extension of SystemF is to add recursive types. However,
[cite:@skorstengaardIntroductionLogicalRelations] has shown
that adding recursive types is a feature that lead to a non-trivial extension of
the logical relation: indeed, we have defined the logical relation inductively
on the structure of type, but unfolding a recursive type does not guarantee the
resulting type to be smaller than the folded one. Thus, it is impossible to
simply extend the logical relation defined in this project.
Similarly, another extension of the language is to add mutable state (for
instance, with pointers)
[cite:@ahmedSemanticsTypesMutable2004; @skorstengaardLogicalRelationsReferences2016]
which leads to a similar issue (we can encode the recursion through the heap,
thanks to the Landin's knot technique).

However, Iris is a step-indexed logic. It provides the logical tools to easily
manage the recursive types. Moreover, because Iris is a logic of resources, it
allows to define the resources of heap and easily implement the mutable state.

** Logical relation as an interpretation of types :noexport:
Another way to understand the logical relation is to see the logical relation as
an interpretation of types. Indeed, the logical relation for the type $\ty$
can be actually seen as the set of expression that behaves as the type $\ty$.
In his notes about logical relation [cite:@sterlingPracticalSemantics], Jon
Sterling points out that some work can be performed in order to make transform
the logical relation as an interpretation of terms, which is compositionnal. We
think that it could be another way to improve the project: explore this option. \input{figures/logrelComp}

* Conclusion
Logical relation are a proof techniques that have been widely studied in the
past decades, and that have shown to be very useful to prove
programming language properties. While doing proof on paper is prone to do
mistake, proof assistants such as Coq tend to give some higher guarantee.
Coq carefully manages every minute details and ensures that every single
lemma are proved. On the other hand, it requires to carefully choose the
implementation representation in order to ease the proofs.

\printbibliography[heading=none]
